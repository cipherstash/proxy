use std::{fmt::Display, sync::Arc};

use derive_more::derive::Display;
use sqltk::parser::ast::{BinaryOperator, ObjectName};
use tracing::{event, instrument, Level};

use crate::{
    unifier::{instantiated_type_env::InstantiatedTypeEnv, AssociatedTypeSelector},
    EqlTrait, Fmt, TypeError,
};

use super::{
    AssociatedType, Constructor, EqlTerm, EqlTraits, NativeValue, Projection, ProjectionColumn,
    ProjectionColumns, TableColumn, Type, TypeEnv, Unifier, Value,
};

/// A `TypeDecl` is a symbollic representation of [`Type`]. Multiple type declarations can be added to a [`TypeEnv`] and
/// when the type environment is "instantiated", they become `Arc<Type>` values.
#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Display)]
pub(crate) enum TypeDecl {
    /// A type variable.
    #[display("{}", _0)]
    Var(VarDecl),
    /// A native type with an optional table-column.
    #[display("{}", _0)]
    Native(NativeDecl),
    /// An EQL column with zero or more [`EqlTrait`] implementations.
    #[display("{}", _0)]
    #[allow(unused)]
    Eql(EqlTerm),
    /// An array with a generic element type.
    #[display("{}", _0)]
    #[allow(unused)]
    Array(ArrayDecl),
    /// An projection generic & optionally aliased columns types.
    #[display("{}", _0)]
    #[allow(unused)]
    Projection(ProjectionDecl),
    /// An associated type of a type.
    #[display("{}", _0)]
    AssociatedType(AssociatedTypeDecl),
    /// A `setof` type
    #[display("{}", _0)]
    SetOf(SetOfDecl),
}

impl TypeDecl {
    /// Recursively finds all of the [`TVar`]s that `self` uses within its definition.  This information is used to
    /// control the order of type instantiation in a [`TypeEnv`].
    pub(crate) fn depends_on(&self) -> Vec<&TVar> {
        match self {
            TypeDecl::Var(VarDecl { tvar, .. }) => {
                if !tvar.0.starts_with("$") {
                    vec![tvar]
                } else {
                    vec![]
                }
            }
            TypeDecl::Native(_) => vec![],
            TypeDecl::Eql(_) => vec![],
            TypeDecl::Array(ArrayDecl(decl)) => decl.depends_on(),
            TypeDecl::Projection(ProjectionDecl(cols)) => {
                cols.iter().flat_map(|col| col.0.depends_on()).collect()
            }
            TypeDecl::AssociatedType(AssociatedTypeDecl { impl_decl, .. }) => {
                impl_decl.depends_on()
            }
            TypeDecl::SetOf(SetOfDecl(decl)) => decl.depends_on(),
        }
    }
}

/// Trait for instantiating a [`Type`] from a [`TypeDecl`].
///
/// # Instantiation modes
///
/// - "in-env" substitutes type variables with concrete types by looking up already initialised types via type variables
///   in the environment.
///
/// - "shallow" does not resolve type variables to concrete types, instead instantiates those as fresh, unique
///   [`Type::Var`] values generated by the [`Unifier`].
///
/// - "concrete" initialises concrete types only and will fail with an error if a [`TypeDecl`] contains a type variable.
pub(crate) trait InstantiateType {
    /// Instantiates a [`Type`] to be used in an [`InstantiatedTypeEnv`].
    ///
    /// This method is called by [`TypeEnv::instantiate`] which controls the initialisation order thus guaranteeing that
    /// dependencies will already be initialised and available from `env`.
    ///
    /// The [`TVar`]s depended upon by `self` will have already been initialised and can be accessed via `env`.
    fn instantiate_in_env(
        &self,
        unifier: &mut Unifier<'_>,
        env: &InstantiatedTypeEnv,
    ) -> Result<Arc<Type>, TypeError>;

    /// Instantiates a [`Type`] without looking up dependencies in an [`InstantiatedTypeEnv`].
    ///
    /// Every dependency is initialised to a fresh [`Type::Var`].
    #[allow(unused)]
    fn instantiate_shallow(&self, unifier: &mut Unifier<'_>) -> Result<Arc<Type>, TypeError>;

    /// Initialises a concrete [`Type`] from a [`TypeDecl`] variant that contains no [`TypeDecl::Var`]s.  If a
    /// `TypeDecl::Var` is encountered then a [`TypeError`] will be returned.
    fn instantiate_concrete(&self) -> Result<Arc<Type>, TypeError>;
}

impl InstantiateType for TypeDecl {
    fn instantiate_in_env(
        &self,
        unifier: &mut Unifier<'_>,
        env: &InstantiatedTypeEnv,
    ) -> Result<Arc<Type>, TypeError> {
        match self {
            TypeDecl::Var(var_decl) => var_decl.instantiate_in_env(unifier, env),
            TypeDecl::Native(native_decl) => native_decl.instantiate_in_env(unifier, env),
            TypeDecl::Eql(eql_term) => eql_term.instantiate_in_env(unifier, env),
            TypeDecl::Array(array_decl) => array_decl.instantiate_in_env(unifier, env),
            TypeDecl::Projection(projection_decl) => {
                projection_decl.instantiate_in_env(unifier, env)
            }
            TypeDecl::AssociatedType(associated_type_decl) => {
                associated_type_decl.instantiate_in_env(unifier, env)
            }
            TypeDecl::SetOf(setof_decl) => setof_decl.instantiate_in_env(unifier, env),
        }
    }

    fn instantiate_concrete(&self) -> Result<Arc<Type>, TypeError> {
        match self {
            TypeDecl::Var(decl) => decl.instantiate_concrete(),
            TypeDecl::Native(decl) => decl.instantiate_concrete(),
            TypeDecl::Eql(decl) => decl.instantiate_concrete(),
            TypeDecl::Array(decl) => decl.instantiate_concrete(),
            TypeDecl::Projection(decl) => decl.instantiate_concrete(),
            TypeDecl::AssociatedType(decl) => decl.instantiate_concrete(),
            TypeDecl::SetOf(decl) => decl.instantiate_concrete(),
        }
    }

    fn instantiate_shallow(&self, unifier: &mut Unifier<'_>) -> Result<Arc<Type>, TypeError> {
        match self {
            TypeDecl::Var(decl) => decl.instantiate_shallow(unifier),
            TypeDecl::Native(decl) => decl.instantiate_shallow(unifier),
            TypeDecl::Eql(decl) => decl.instantiate_shallow(unifier),
            TypeDecl::Array(decl) => decl.instantiate_shallow(unifier),
            TypeDecl::Projection(decl) => decl.instantiate_shallow(unifier),
            TypeDecl::AssociatedType(decl) => decl.instantiate_shallow(unifier),
            TypeDecl::SetOf(decl) => decl.instantiate_shallow(unifier),
        }
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Display)]
#[display("[{}]", _0)]
pub(crate) struct ArrayDecl(pub(crate) Box<TypeDecl>);

impl InstantiateType for ArrayDecl {
    fn instantiate_in_env(
        &self,
        unifier: &mut Unifier<'_>,
        env: &InstantiatedTypeEnv,
    ) -> Result<Arc<Type>, TypeError> {
        Ok(Type::array(self.0.instantiate_in_env(unifier, env)?))
    }

    fn instantiate_concrete(&self) -> Result<Arc<Type>, TypeError> {
        Ok(Type::array(self.0.instantiate_concrete()?))
    }

    fn instantiate_shallow(&self, unifier: &mut Unifier<'_>) -> Result<Arc<Type>, TypeError> {
        Ok(Type::array(self.0.instantiate_shallow(unifier)?))
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub(crate) struct VarDecl {
    pub(crate) tvar: TVar,
    pub(crate) bounds: EqlTraits,
}

impl Display for VarDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{}", self.tvar))?;
        if self.bounds != EqlTraits::none() {
            f.write_fmt(format_args!(": {}", self.bounds))?;
        }
        Ok(())
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Display)]
pub(crate) struct TVar(#[display("${}", _0)] pub(crate) String);

impl InstantiateType for VarDecl {
    fn instantiate_in_env(
        &self,
        unifier: &mut Unifier<'_>,
        env: &InstantiatedTypeEnv,
    ) -> Result<Arc<Type>, TypeError> {
        if !self.tvar.0.starts_with("$") {
            env.get_type(&self.tvar)
        } else {
            Ok(unifier.fresh_bounded_tvar(self.bounds))
        }
    }

    fn instantiate_concrete(&self) -> Result<Arc<Type>, TypeError> {
        Err(TypeError::InternalError(
            "tried to build a concrete type from a typedecl containing a type variable".into(),
        ))
    }

    fn instantiate_shallow(&self, unifier: &mut Unifier<'_>) -> Result<Arc<Type>, TypeError> {
        Ok(unifier.fresh_bounded_tvar(self.bounds))
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub(crate) struct ProjectionDecl(pub(crate) Vec<ProjectionColumnDecl>);

impl Display for ProjectionDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str("{")?;
        for (idx, col) in self.0.iter().enumerate() {
            f.write_fmt(format_args!("{}", col))?;
            if idx < self.0.len() - 1 {
                f.write_str(",")?;
            }
        }
        f.write_str("}")
    }
}

impl InstantiateType for ProjectionDecl {
    fn instantiate_in_env(
        &self,
        unifier: &mut Unifier<'_>,
        env: &InstantiatedTypeEnv,
    ) -> Result<Arc<Type>, TypeError> {
        Ok(Arc::new(Type::Constructor(Constructor::Projection(
            Projection::WithColumns(ProjectionColumns(
                self.0
                    .iter()
                    .map(|col_decl| -> Result<_, TypeError> {
                        Ok(ProjectionColumn::new(
                            col_decl.0.instantiate_in_env(unifier, env)?,
                            col_decl.1.clone(),
                        ))
                    })
                    .collect::<Result<Vec<_>, _>>()?,
            )),
        ))))
    }

    fn instantiate_concrete(&self) -> Result<Arc<Type>, TypeError> {
        Ok(Arc::new(Type::Constructor(Constructor::Projection(
            Projection::WithColumns(ProjectionColumns(
                self.0
                    .iter()
                    .map(|col_decl| -> Result<_, TypeError> {
                        Ok(ProjectionColumn::new(
                            col_decl.0.instantiate_concrete()?,
                            col_decl.1.clone(),
                        ))
                    })
                    .collect::<Result<Vec<_>, _>>()?,
            )),
        ))))
    }

    fn instantiate_shallow(&self, unifier: &mut Unifier<'_>) -> Result<Arc<Type>, TypeError> {
        Ok(Arc::new(Type::Constructor(Constructor::Projection(
            Projection::WithColumns(ProjectionColumns(
                self.0
                    .iter()
                    .map(|col_decl| -> Result<_, TypeError> {
                        Ok(ProjectionColumn::new(
                            col_decl.0.instantiate_shallow(unifier)?,
                            col_decl.1.clone(),
                        ))
                    })
                    .collect::<Result<Vec<_>, _>>()?,
            )),
        ))))
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub(crate) struct ProjectionColumnDecl(
    pub(crate) Box<TypeDecl>,
    pub(crate) Option<sqltk::parser::ast::Ident>,
);

impl Display for ProjectionColumnDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{}", self.0))?;
        if let Some(alias) = &self.1 {
            f.write_fmt(format_args!(" as {}", alias))?;
        }
        Ok(())
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Display)]
#[display("<{} as {}>::{}", impl_decl, as_eql_trait, type_name)]
pub(crate) struct AssociatedTypeDecl {
    pub(crate) impl_decl: Box<TypeDecl>,
    pub(crate) as_eql_trait: EqlTrait,
    pub(crate) type_name: &'static str,
}

impl InstantiateType for AssociatedTypeDecl {
    fn instantiate_in_env(
        &self,
        unifier: &mut Unifier<'_>,
        env: &InstantiatedTypeEnv,
    ) -> Result<Arc<Type>, TypeError> {
        let impl_ty = self.impl_decl.instantiate_in_env(unifier, env)?;
        let resolved_ty = unifier.fresh_tvar();

        Ok(Arc::new(Type::Associated(AssociatedType {
            impl_ty,
            resolved_ty,
            selector: AssociatedTypeSelector::new(self.as_eql_trait, self.type_name)?,
        })))
    }

    fn instantiate_concrete(&self) -> Result<Arc<Type>, TypeError> {
        let impl_ty = self.impl_decl.instantiate_concrete()?;
        let selector = AssociatedTypeSelector::new(self.as_eql_trait, self.type_name)?;
        let resolved_ty = selector.resolve(impl_ty.clone())?;

        Ok(Arc::new(Type::Associated(AssociatedType {
            impl_ty,
            resolved_ty,
            selector,
        })))
    }

    fn instantiate_shallow(&self, unifier: &mut Unifier<'_>) -> Result<Arc<Type>, TypeError> {
        let impl_ty = self.impl_decl.instantiate_shallow(unifier)?;
        let selector = AssociatedTypeSelector::new(self.as_eql_trait, self.type_name)?;
        let resolved_ty = selector.resolve(impl_ty.clone())?;

        Ok(Arc::new(Type::Associated(AssociatedType {
            impl_ty,
            resolved_ty,
            selector,
        })))
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub(crate) struct SetOfDecl(pub Box<TypeDecl>);

impl Display for SetOfDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("SetOf<{}>", self.0))
    }
}

impl InstantiateType for SetOfDecl {
    fn instantiate_in_env(
        &self,
        unifier: &mut Unifier<'_>,
        env: &InstantiatedTypeEnv,
    ) -> Result<Arc<Type>, TypeError> {
        Ok(Type::set_of(self.0.instantiate_in_env(unifier, env)?).into())
    }

    fn instantiate_concrete(&self) -> Result<Arc<Type>, TypeError> {
        Ok(Type::set_of(self.0.instantiate_concrete()?).into())
    }

    fn instantiate_shallow(&self, unifier: &mut Unifier<'_>) -> Result<Arc<Type>, TypeError> {
        Ok(Type::set_of(self.0.instantiate_shallow(unifier)?).into())
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub(crate) struct BoundsDecl(pub(crate) TVar, pub(crate) EqlTraits);

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct FunctionDecl {
    /// The function name.
    pub(crate) name: ObjectName,
    /// The declaration of this function.
    pub(crate) inner: FunctionSignatureDecl,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct BinaryOpDecl {
    /// The binary operator.
    pub(crate) op: BinaryOperator,
    /// The declaration of this binary operator as a 2-argument function.
    pub(crate) inner: FunctionSignatureDecl,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct FunctionSignatureDecl {
    /// The type type variables for args.
    arg_tvars: Vec<TVar>,

    /// The type variable for the return type.
    ret_tvar: TVar,

    /// The type environment.
    type_env: TypeEnv,
}

impl FunctionSignatureDecl {
    /// The generic args of this function - the generic args are local to this function definition.  The ONLY type
    /// variables allowed to be referenced in `args`, `ret` and `bounds`.
    pub(crate) fn new(
        generic_args: Vec<TVar>,
        generic_bounds: Vec<BoundsDecl>,
        arg_decls: Vec<TypeDecl>,
        ret_decl: TypeDecl,
    ) -> Result<Self, TypeError> {
        Self::check_no_undeclared_generic_args(
            &generic_args,
            &generic_bounds,
            &arg_decls,
            &ret_decl,
        )?;

        let (type_env, (arg_tvars, ret_tvar)) = TypeEnv::build(|type_env| {
            for tvar in generic_args {
                let decl = match generic_bounds.iter().find(|bound| bound.0 == tvar) {
                    Some(bounds) => TypeDecl::Var(VarDecl {
                        tvar: type_env.fresh_tvar(),
                        bounds: bounds.1,
                    }),
                    None => TypeDecl::Var(VarDecl {
                        tvar: type_env.fresh_tvar(),
                        bounds: EqlTraits::none(),
                    }),
                };

                type_env.add_decl(tvar, decl);
            }

            let arg_tvars = arg_decls
                .into_iter()
                .map(|decl| -> Result<TVar, TypeError> { type_env.add_decl_with_indirection(decl) })
                .collect::<Result<Vec<_>, _>>()?;

            let ret_tvar = type_env.add_decl_with_indirection(ret_decl)?;

            Ok((arg_tvars, ret_tvar))
        })?;

        Ok(Self {
            arg_tvars,
            ret_tvar,
            type_env,
        })
    }

    #[instrument(
        target = "eql-mapper::UNIFY",
        skip(self, unifier),
        level = "trace",
        err(Debug),
        fields(
            args = %Fmt(args),
            ret = %ret,
            return = tracing::field::Empty,
        )
    )]
    pub(crate) fn apply(
        &self,
        unifier: &mut Unifier<'_>,
        args: &[Arc<Type>],
        ret: Arc<Type>,
    ) -> Result<InstantiatedTypeEnv, TypeError> {
        let span = tracing::Span::current();

        let result = (|| {
            if args.len() != self.arg_tvars.len() {
                return Err(TypeError::Expected(format!(
                    "incorrect number of arguments; got {}, expected {}",
                    args.len(),
                    self.arg_tvars.len()
                )));
            }

            event!(
                target: "eql-mapper::TYPE_ENV",
                Level::TRACE,
                type_env = %self.type_env
            );

            let instantiated_env = self.type_env.instantiate(unifier)?;

            event!(
                target: "eql-mapper::TYPE_ENV",
                Level::TRACE,
                instantiated = %instantiated_env
            );

            for (arg, arg_tvar) in args.iter().zip(self.arg_tvars.iter()) {
                unifier.unify(arg.clone(), instantiated_env.get_type(arg_tvar)?)?;
            }

            unifier.unify(ret.clone(), instantiated_env.get_type(&self.ret_tvar)?)?;

            event!(
                target: "eql-mapper::TYPE_ENV",
                Level::TRACE,
                env_after_args_and_ret_unified = %instantiated_env
            );

            Ok(instantiated_env)
        })();

        if let Ok(ref instantiated_env) = result {
            span.record("return", tracing::field::display(instantiated_env));
        }

        result
    }

    fn check_no_undeclared_generic_args<'a>(
        generic_args: &'a [TVar],
        generic_bounds: &'a Vec<BoundsDecl>,
        args: &'a [TypeDecl],
        ret: &'a TypeDecl,
    ) -> Result<(), TypeError> {
        let is_vardecl = |arg: &'a TypeDecl| {
            if let TypeDecl::Var(VarDecl { tvar, .. }) = arg {
                Some(tvar)
            } else {
                None
            }
        };

        let check_known = |tvar: &TVar| -> Result<(), TypeError> {
            if generic_args.contains(tvar) {
                Ok(())
            } else {
                Err(TypeError::InternalError(format!(
                    "use of undeclared type var '{}'",
                    tvar
                )))
            }
        };

        args.iter()
            .filter_map(is_vardecl)
            .try_fold((), |_, tvar| check_known(tvar))?;

        if let Some(tvar) = is_vardecl(ret) {
            check_known(tvar)?;
        }

        for bound in generic_bounds {
            if !generic_args.contains(&bound.0) {
                return Err(TypeError::InternalError(format!(
                    "generic bounds references undefined type variable '{}'",
                    bound.0
                )));
            }
        }

        Ok(())
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub(crate) struct NativeDecl(pub(crate) Option<TableColumn>);

impl Display for NativeDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.0 {
            Some(tc) => f.write_fmt(format_args!("Native({})", tc)),
            None => f.write_fmt(format_args!("Native")),
        }
    }
}

impl InstantiateType for NativeDecl {
    fn instantiate_in_env(
        &self,
        _: &mut Unifier<'_>,
        _: &InstantiatedTypeEnv,
    ) -> Result<Arc<Type>, TypeError> {
        self.instantiate_concrete()
    }

    fn instantiate_concrete(&self) -> Result<Arc<Type>, TypeError> {
        match &self.0 {
            Some(tc) => Ok(Arc::new(Type::Constructor(Constructor::Value(
                Value::Native(NativeValue(Some(tc.clone()))),
            )))),
            None => Ok(Arc::new(Type::Constructor(Constructor::Value(
                Value::Native(NativeValue(None)),
            )))),
        }
    }

    fn instantiate_shallow(&self, _: &mut Unifier<'_>) -> Result<Arc<Type>, TypeError> {
        self.instantiate_concrete()
    }
}

impl InstantiateType for EqlTerm {
    fn instantiate_in_env(
        &self,
        _: &mut Unifier<'_>,
        _: &InstantiatedTypeEnv,
    ) -> Result<Arc<Type>, TypeError> {
        self.instantiate_concrete()
    }

    fn instantiate_concrete(&self) -> Result<Arc<Type>, TypeError> {
        Ok(Arc::new(Type::Constructor(Constructor::Value(Value::Eql(
            self.clone(),
        )))))
    }

    fn instantiate_shallow(&self, _: &mut Unifier<'_>) -> Result<Arc<Type>, TypeError> {
        self.instantiate_concrete()
    }
}
