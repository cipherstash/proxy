[settings]
# Config for test environments
# Can be invoked with: mise --env tcp run <task>
trusted_config_paths = [
  "./tests/mise.toml",
  "./tests/mise.tcp.toml",
  "./tests/mise.tls.toml",
]

[task_config]
includes = ["tests/tasks"]

[vars]
database_port = "5532" # default postgres port using built in docker-compose setup

[env]
# Default configuration for running cipherstash-proxy out of the box
CS_DATABASE__NAME = "cipherstash"
CS_DATABASE__USERNAME = "cipherstash"
CS_DATABASE__PASSWORD = "password"
CS_DATABASE__HOST = "localhost"
CS_DATABASE__PORT = "5532"
# Default configuration for dev cipherstash-proxy run using 'mise run proxy:up'
CS_PROXY__HOST = "proxy"
# Misc
DOCKER_CLI_HINTS = "false" # Please don't show us What's Next.

[tools]
"cargo:cargo-binstall" = "latest"
"cargo:cargo-nextest" = "latest"
"cargo:cargo-sort" = "latest"

# ====================================================================================================
# Proxy Tasks
[tasks.proxy]
alias = 'p'
description = "Run the proxy (with `cargo run`)"
run = 'pwd && env | grep CS_ && cargo run {{option(name="extra-args",default="")}}'

[tasks."proxy:kill"]
alias = 'k'
description = "Kill running cipherstash-proxy processes"
run = """
  set +e
  killall cipherstash-proxy -s SIGINT
  exit 0
"""

[tasks."proxy:up"]
description = "Run Proxy instance with docker compose"
dir = "{{config_root}}/tests"
run = """
#!/bin/bash
{% set target = arch() ~ "-unknown-linux-gnu" | replace(from="arm64", to="aarch64") | replace(from="x64", to="x86_64") %}
{% set docker_platform = "linux/" ~ arch() | replace(from="x64", to="amd64") %}

{# If we are on macos, cross-compile for Linux, so we can run the binary in a Docker container. #}
{# Only supports Apple Silicon. #}
{% if os() == "macos" %}
if ! which {{ target }}-gcc ; then
  brew install MaterializeInc/crosstools/aarch64-unknown-linux-gnu
fi
export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER={{ target }}-gcc
{% endif %}

# cross-compile
rustup target add --toolchain stable {{ target }}

cargo build --locked --target {{ target }} --release --package cipherstash-proxy

cp {{config_root}}/target/{{ target }}/release/cipherstash-proxy {{config_root}}/

# build a new container
mise run build:docker --platform {{docker_platform}}

# if [[ "{{arg(name="service",default="proxy")}}" =~ "proxy-tls" ]]; then
#   if [ -z "${CS_TLS__CERTIFICATE}" ]; then
#     echo "error: CS_TLS__CERTIFICATE is not set, and you are trying to bring up the proxy-tls container"
#   fi
#   if [ -z "${CS_TLS__PRIVATE_KEY}" ]; then
#     echo "error: CS_TLS__PRIVATE_KEY is not set, and you are trying to bring up the proxy-tls container"
#   fi
#   if [ -z "${CS_TLS__CERTIFICATE}" ] || [ -z "${CS_TLS__CERTIFICATE}" ]; then
#     exit 67
#   fi
# fi

# Make the default invocation with `mise run proxy:up` work.
# The default mise environment configuration works for Proxy running as a process, connecting via a port forward.
# Try detecting a running postgres, and use it
if [ "${CS_DATABASE__HOST}" == "localhost" ]; then
  {% raw %}
  running_postgres="$(docker ps --filter "name=postgres" --filter "health=healthy" --format "{{.Names}};{{.Ports}}" | grep ${CS_DATABASE__PORT})"
  {% endraw %}
  if [ -z "${running_postgres}" ]; then
    echo "error: Could not detect a running, healthy postgres container with port ${CS_DATABASE__PORT}"
    echo "error: Try running 'mise run postgres:up' to start a container"
    exit 68
  fi
  echo $running_postgres
  export CS_DATABASE__HOST=$(echo $running_postgres | cut -d ';' -f 1)
  echo "Using postgres running in container: ${CS_DATABASE__HOST}"
fi

# run the container
echo docker compose up {{arg(name="service",default="proxy")}} {{option(name="extra-args",default="")}} | bash
"""

[tasks."proxy:psql"]
description="Run psql (interactively) against the proxy; assumes the proxy is already up"
run = """
set -eu
docker exec -it postgres${CONTAINER_SUFFIX:-} psql "postgresql://${CS_DATABASE__USERNAME}:${CS_DATABASE__PASSWORD}@${CS_PROXY__HOST}:6432/${CS_DATABASE__NAME}"
"""

[tasks."proxy:down"]
dir = "{{config_root}}/tests"
description = "Tear down Proxy containers"
# `docker compose down` works differently on Linux and macOS.
# Depending on the operating system and version, services sometimes can't be named.
# Run `docker compose rm` directly, to emulate what `docker compose down` does.
run = "docker compose rm --stop --force proxy proxy-tls"

# ====================================================================================================
# Test Tasks

[tasks.test]
alias = [ 't', 'ci' ]
description = "Runs all tests (hygiene, unit, integration)"
run = """
mise run test:check
mise run test:format
mise run test:clippy
mise run test:unit
mise run test:integration
"""

[tasks."test:local:unit"]
alias = 'lu'
description = "Runs test/s"
run = """
cargo nextest run --no-fail-fast --nocapture -p cipherstash-proxy
"""

[tasks."test:local:integration"]
alias = 'li'
description = "Runs test/s"
run = """
cargo nextest run --no-fail-fast --nocapture -p cipherstash-proxy-integration
"""

[tasks."test:unit"]
description = "Runs test/s"
run = "mise run test:nextest {{arg(name='test',default='')}}"


[tasks."test:wait_for_postgres_to_quack"]
dir = "{{config_root}}"
run = """
{% set default_host = get_env(name="CS_DATABASE__HOST",default="localhost") %}
{% set default_port = get_env(name="CS_DATABASE__PORT",default=5432) %}
host={{option(name="host",default=default_host)}}
port={{option(name="port",default=default_port)}}
tls={{flag(name="tls")}}
max_retries={{option(name="max-retries",default="4")}}
interval={{option(name="interval",default="0.5")}}
attempt=1
echo "Testing presence of Postgres at ${host}:${port} with a maximum of ${max_retries} retries"

postgres_ready () {
  # tls test
  if [ "$1" = "true" ]; then
    response="$(echo | openssl s_client -starttls postgres -connect $host:$port -state -no_ign_eof 2>&1)"
    success=$?
    if [ -n "${DEBUG}" ]; then
      echo "response: ${response}"
    fi
    return $success
  else
    # plaintext test
    # We blackhole stderr (2>/dev/null) below because nc is echoing to stderr,
    # and that *sometimes* gets mise in a tizz. (There's some condition we're
    # triggering in [at least] Mise v2025.1.6, and accordingly need to avoid
    # echoing the raw response out to stdout or stderr without putting it
    # through od or similar.)
    response=$(cat tests/pg/startup_message.bin | nc -v -w 1 $host $port 2>/dev/null)
    if [ -n "${DEBUG}" ]; then
      echo "response:"
      printf "%s" "${response}" | od -c
      echo "number of response bytes:"
      printf "%s" "${response}" | wc -c
    fi
    # FIXME(lindsay): also detect if we see TLS failures
    if [ -n "${response}" ]; then
      return 0
    fi
    return 1
  fi
}

until postgres_ready $tls
do
  if [ $attempt -lt $max_retries ]; then
    echo "Waiting for ${host}:${port}"
    sleep $interval
    attempt=$(expr $attempt + 1)
  else
    echo "Unable to connect to ${host}:${port} after ${max_retries} attempts"
    exit 64
  fi
done
echo "Connected to ${host}:${port} after ${attempt} attempts"
"""

[tasks."test:integration:preflight"]
description = "Ensure dependencies are ready for running the integration tests"
run = '''
set -u
set +e

# 5532: non-TLS, Postgres latest
# 5617: TLS, PostgreSQL version 17
ports="5532 5617"

for i in ${ports}; do
  # 55xx ports are always non-TLS, 56xx ports are always TLS
  TLS=""
  if [ "$i" -gt 5600 ] && [ "$i" -le 5699 ]; then
    TLS="--tls"
  fi

  mise run test:wait_for_postgres_to_quack --port ${i} --max-retries 20 ${TLS}
  if [ $? -ne 0 ]; then
    echo "error: Postgres not running on port ${i}"
    echo "error: Try running 'mise run postgres:up' to start the containers"
    exit 66
  fi
done

# Ensure all Proxy services are stopped before we start the tests
mise --env tcp run proxy:down
'''

[tasks."test:integration"]
alias = "i"
dir = "./tests"
description = "Runs integration test/s"
run = """
set -e

echo
echo '###############################################'
echo '# Setup'
echo '###############################################'
echo

# Ensure Postgres instances are running
mise run test:integration:preflight

# Ensure EQL is set up before we try and start Proxy
mise --env tcp run postgres:setup
mise --env tls run postgres:setup

echo
echo '###############################################'
echo '# Test: non-TLS'
echo '###############################################'
echo

mise --env tcp run proxy:up proxy --extra-args "--detach --wait"
mise --env tcp run test:wait_for_postgres_to_quack --port 6432 --max-retries 20
mise --env tcp run test:integration:psql-tcp
mise --env tcp run proxy:down

echo
echo '###############################################'
echo '# Test: TLS'
echo '###############################################'
echo

mise --env tls run proxy:up proxy-tls --extra-args "--detach --wait"
mise --env tls run test:wait_for_postgres_to_quack --port 6432 --max-retries 20 --tls
mise --env tls run test:integration:psql-tls
mise --env tls run proxy:down

echo
echo '###############################################'
echo '# Test: Integration'
echo '###############################################'
echo

mise --env tls run proxy:up proxy-tls --extra-args "--detach --wait"
mise --env tls run test:wait_for_postgres_to_quack --port 6432 --max-retries 20 --tls
cargo nextest run --no-fail-fast --nocapture -E 'package(cipherstash-proxy-integration)'
mise --env tls run proxy:down

echo
echo '###############################################'
echo '# Test: Python'
echo '###############################################'
echo

mise --env tls run proxy:up proxy-tls --extra-args "--detach --wait"
mise --env tls run test:wait_for_postgres_to_quack --port 6432 --max-retries 20 --tls
mise --env tls run python:test
mise --env tls run proxy:down
"""

[tasks."test:nextest"]
description = "Runs cargo nextest, skipping integration tests"
run = 'cargo nextest run --no-fail-fast --nocapture -E "not package(cipherstash-proxy-integration)" {{arg(name="test",default="")}}'

[tasks."test:format"]
description = "Runs cargo fmt"
run = 'cargo fmt --all -- --check'

[tasks."test:check"]
description = "Runs cargo check"
run = 'cargo check'

[tasks."test:clippy"]
description = "Runs clippy"
run = 'cargo clippy --all --no-deps --all-targets --all-features'

[tasks."postgres:fail_if_not_running"]
description = "Check if postgres containers are running, and fail if not"
run = """
containers=$(docker ps --filter "name=postgres${CONTAINER_SUFFIX}" --quiet)
if [ -z "${containers}" ]; then
  echo "error: Docker containers for PostgreSQL are not running"
  echo "error: Try running 'mise run postgres:up' to start the containers"
  exit 65
fi
"""

[tasks."postgres:setup"]
alias = 's'
description = "Installs EQL and applies schema to database"
run = """
#!/bin/bash
cd tests
mise run postgres:fail_if_not_running
mise run postgres:eql:download
cat sql/cipherstash-encrypt.sql | docker exec -i postgres${CONTAINER_SUFFIX} psql postgresql://${CS_DATABASE__USERNAME}:${CS_DATABASE__PASSWORD}@${CS_DATABASE__HOST}:${CS_DATABASE__PORT}/${CS_DATABASE__NAME} -f-
cat sql/schema.sql | docker exec -i postgres${CONTAINER_SUFFIX} psql postgresql://${CS_DATABASE__USERNAME}:${CS_DATABASE__PASSWORD}@${CS_DATABASE__HOST}:${CS_DATABASE__PORT}/${CS_DATABASE__NAME} -f-
"""

[tasks."postgres:up"]
alias = 'u'
dir = "{{config_root}}/tests"
description = "Run Postgres instances with docker compose"
run = """
set -e
# Start the containers
echo docker compose up --build {{arg(name="service",default="postgres postgres-17-tls")}} {{option(name="extra-args",default="")}} | bash
"""

[tasks."postgres:psql"]
description="Run psql (interactively) against the Postgres instance; assumes Postgres is already up"
run = """
set -eu
docker exec -it postgres${CONTAINER_SUFFIX:-} psql "postgresql://${CS_DATABASE__USERNAME}:${CS_DATABASE__PASSWORD}@${CS_DATABASE__HOST}:${CS_DATABASE__PORT}/${CS_DATABASE__NAME}"
"""

[tasks."postgres:down"]
alias = 'd'
description = 'Tear down containers and destroy all data'
run = """
  mise run postgres:compose_down
  mise run postgres:destroy_data
"""

[tasks."postgres:compose_down"]
dir = "./tests"
description = "docker compose down"
run = 'docker compose down'

[tasks."postgres:destroy_data"]
alias = 'dd'
dir = "{{config_root}}"
description = "Removes the local data directories"
run = """
{% if os() == "linux" %}
{% set stat_cmd = "stat --format='%u'" %}
{% else %}
{% set stat_cmd = "stat -f '%Uu'" %}
{% endif %}
set -e
set -u
if test -z "$(find tests/pg -maxdepth 1 -name 'data-*' -print -quit)"; then
  echo "no data directories to clean up - skipping"
  exit 0
fi

uid=$(id -u)
for d in tests/pg/data-*; do
  sudo=""
  if [ "$({{stat_cmd}} ${d})" != "${uid}" ]; then
    sudo="sudo"
  fi
  echo "removing data directory ${d}"
  ${sudo} rm -rf ${d}
done
"""


[tasks."postgres:eql:download"]
alias = 'e'
description = "Download latest EQL release"
dir = "{{config_root}}/tests"
outputs = ["{{config_root}}/tests/sql/cipherstash-encrypt.sql"]
run = """
if [ -z "$CS_EQL_PATH" ]; then
  curl -sLo sql/cipherstash-encrypt.sql https://github.com/cipherstash/encrypt-query-language/releases/latest/download/cipherstash-encrypt.sql
else
  echo "Using EQL: ${CS_EQL_PATH}"
  cp "$CS_EQL_PATH" sql/cipherstash-encrypt.sql
fi
"""


[tasks."python:test"]
dir = "{{config_root}}/tests"
description = "Runs python tests"
run = """
set -e
echo docker compose run --no-TTY --build python {{option(name="extra-args",default="")}} | bash
"""

[tasks.build]
description = "Build releasable artifacts"
run = """
{% set default_platform = "linux/" ~ arch() | replace(from="x86_64", to="amd64") %}
mise run build:binary
mise run build:docker --platform {{option(name="platform",default=default_platform)}}
"""

[tasks."build:binary"]
description = "Build a releasable binary for cipherstash-proxy"
run = """
cargo build --locked --release --package cipherstash-proxy
cp -v target/release/cipherstash-proxy .
"""

[tasks."build:docker"]
depends = ["build:docker:fetch_eql"]
description = "Build a Docker image for cipherstash-proxy"
run = """
{% set default_platform = "linux/" ~ arch() | replace(from="x86_64", to="amd64") %}
docker build . \
  --tag cipherstash/proxy:latest \
  --file proxy.Dockerfile \
  --platform {{option(name="platform",default=default_platform)}} \
"""

[tasks."build:docker:fetch_eql"]
description = "Fetch the EQL installation script"
run = """
if [ ! -e "cipherstash-eql.sql" ]; then
  echo "Fetching: cipherstash-eql.sql"
  curl -sLo cipherstash-eql.sql https://github.com/cipherstash/encrypt-query-language/releases/latest/download/cipherstash-encrypt.sql
else
  echo "Prefetched: cipherstash-eql.sql"
fi
"""

[tasks.release]
description = "Publish release artifacts"
depends = ["release:docker"]

[tasks."release:docker"]
description = "Release a Docker image for cipherstash-proxy"
run = """
if [ -z "$DOCKER_HUB_USERNAME" ] || [ -z "$DOCKER_HUB_PERSONAL_ACCESS_TOKEN" ]; then
  echo "error: no Docker Hub credentials provided"
  echo "error: please set DOCKER_HUB_USERNAME and DOCKER_HUB_PERSONAL_ACCESS_TOKEN"
  exit 2
fi
echo "Logging in to Docker Hub..."
echo $DOCKER_HUB_PERSONAL_ACCESS_TOKEN | docker login --username $DOCKER_HUB_USERNAME --password-stdin
docker tag cipherstash/proxy:latest cipherstash/proxy:latest
docker push cipherstash/proxy:latest
"""

# ====================================================================================================
