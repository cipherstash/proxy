[settings]
# Config for test environments
# Can be invoked with: mise --env tcp run <task>
trusted_config_paths = [
  "./tests/mise.toml",
  "./tests/mise.tcp.toml",
  "./tests/mise.tls.toml",
]

[task_config]
includes = ["tests/tasks"]

[vars]
database_port = "5532" # default postgres port using built in docker-compose setup

[env]
# Default configuration for running cipherstash-proxy out of the box
CS_DATABASE__NAME = "cipherstash"
CS_DATABASE__USERNAME = "cipherstash"
CS_DATABASE__PASSWORD = "password"
CS_DATABASE__HOST = "localhost"
CS_DATABASE__PORT = "5532"

[tools]
"cargo:cargo-binstall" = "latest"
"cargo:cargo-nextest" = "latest"
"cargo:cargo-sort" = "latest"

# ====================================================================================================
# Proxy Tasks
[tasks.proxy]
alias = 'p'
description = "Run the proxy (with `cargo run`)"
run = 'pwd && env | grep CS_ && cargo run'

[tasks."proxy:kill"]
alias = 'k'
description = "Kill running cipherstash-proxy processes"
run = """
  set +e
  killall cipherstash-proxy -s SIGINT
  exit 0
"""

[tasks."proxy:up"]
description = "Run Proxy instance with docker compose"
dir = "{{config_root}}/tests"
run = """
{% set target = arch() ~ "-unknown-linux-gnu" | replace(from="arm64", to="aarch64") %}
{% set toolchain = "stable-" ~ arch() ~ "-unknown-linux-gnu" | replace(from="arm64", to="aarch64") %}

{% if os() == "macos" %}
if ! which aarch64-unknown-linux-gnu ; then
  brew install MaterializeInc/crosstools/aarch64-unknown-linux-gnu
fi
{% endif %}

# cross-compile
#rustup toolchain install stable-aarch64-apple-darwin


rustup target add --toolchain stable {{ target }}

export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-unknown-linux-gnu-gcc
export TARGET_CC=aarch64-unknown-linux-gnu-gcc

cargo build --locked --target {{ target }} --release --package cipherstash-proxy

# run the container
echo docker compose up --build proxy {{option(name="extra-args",default="")}} | bash
"""

[tasks."proxy:down"]
dir = "./tests"
description = "Tear down Proxy containers"
run = "docker compose down proxy"

# ====================================================================================================
# Test Tasks

[tasks."test:unit"]
alias = ['t', 'test']
description = "Runs tests"
run = "mise run test:nextest {{arg(name='test',default='')}}"

[tasks."test:ci"]
alias = "ci"
description = "Runs test/s"
run = """
  mise run test:check
  mise run test:format
  mise run test:clippy
  mise run test:unit
"""

[tasks."test:wait_for_tcp_port"]
run = """
{% set default_host = get_env(name="CS_DATABASE__HOST",default="localhost") %}
{% set default_port = get_env(name="CS_DATABASE__PORT",default=5432) %}
  host={{option(name="host",default=default_host)}}
  port={{option(name="port",default=default_port)}}
  max_retries=10
  attempt=1
  until nc -z $host $port
  do
    if [ $attempt -lt $max_retries ]; then
      echo "Waiting for ${host}:${port}"
      sleep 0.5
      attempt=$(expr $attempt + 1)
    else
      echo "Unable to connect to ${host}:${port} after ${max_retries} attempts"
      exit 64
    fi
  done
  echo "Connected to ${host}:${port} after ${attempt} attempts"
"""

[tasks."test:integration"]
alias = "i"
dir = "./tests"
description = "Runs integration test/s"
run = """
  # Build a binary once
  mise run build:binary

  # Ensure proxy is not running
  mise run proxy:kill

  mise --env tcp run postgres:setup
  mise --env tcp exec -- ../cipherstash-proxy &
  mise --env tcp run test:wait_for_tcp_port --port 6432
  mise --env tcp run test:psql-tcp
  mise run proxy:kill

  mise --env tls run postgres:setup
  mise --env tls exec -- ../cipherstash-proxy &
  mise --env tls run test:wait_for_tcp_port --port 6432
  mise --env tls run test:psql-tls
  mise run proxy:kill

  mise --env tls run postgres:setup
  mise --env tls exec -- ../cipherstash-proxy &
  mise --env tls run test:wait_for_tcp_port --port 6432
  cargo nextest run --no-fail-fast --nocapture -E 'test(~integration)'
  mise run proxy:kill
"""

[tasks."test:nextest"]
description = "Runs cargo nextest, skipping integration tests"
run = 'cargo nextest run --no-fail-fast --nocapture -E "not test(~integration)" {{arg(name="test",default="")}}'

[tasks."test:format"]
description = "Runs cargo fmt"
run = 'cargo fmt --all -- --check'

[tasks."test:check"]
description = "Runs cargo check"
run = 'cargo check'

[tasks."test:clippy"]
description = "Runs clippy"
run = 'cargo clippy --all --no-deps --all-targets --all-features'

[tasks."postgres:fail_if_not_running"]
description = "Check if postgres containers are running, and fail if not"
run = """
containers=$(docker ps --filter "name=postgres${CONTAINER_SUFFIX}" --quiet)
if [ -z "${containers}" ]; then
  echo "error: Docker containers for PostgreSQL are not running"
  echo "error: Try running 'mise run postgres:up' to start the containers"
  exit 65
fi
"""

[tasks."postgres:setup"]
depends = ["postgres:fail_if_not_running", "postgres:install_eql"]
alias = 's'
description = "Installs EQL and applies schema to database"
run = """
  #!/bin/bash
  cd tests
  cat sql/schema.sql | docker exec -i postgres${CONTAINER_SUFFIX} psql postgresql://${CS_DATABASE__USERNAME}:${CS_DATABASE__PASSWORD}@${CS_DATABASE__HOST}:${CS_DATABASE__PORT}/cipherstash -f-
"""

[tasks."postgres:up"]
alias = 'u'
dir = "{{config_root}}/tests"
description = "Run Postgres instances with docker compose"
run = """
set -e
set -u

# For Ubuntu 24.04
if [ '{{os()}}' = 'linux' ]; then
  target_uid=999 # the uid of the postgres user inside the postgres containers
  target_mode=600 # the file mode postgres needs to read certs and key material
  for f in {{config_root}}/tests/tls/*; do
    current_uid="$(stat --format='%u' ${f})"
    if [ "${current_uid}" != "${target_uid}" ]; then
      echo "Changing file owner from ${current_uid} to ${target_uid}: ${f}"
      sudo chown ${target_uid}:${target_uid} ${f}
    fi
    current_mode="$(stat --format='%a' ${f})"
    if [ "${current_mode}" != "${target_mode}" ]; then
      echo "Changing file permissions from ${current_mode} to ${target_mode}: ${f}"
      sudo chmod $target_mode $f
    fi
  done
fi

# For macOS 14.7
if [ '{{os()}}' = 'macos' ]; then
  target_mode=600 # the file mode postgres needs to read certs and key material
  chmod $target_mode tls/*
fi

# Start the containers
echo docker compose up --build {{arg(name="service",default="postgres postgres-17-tls")}} {{option(name="extra-args",default="")}} | bash
"""

[tasks."postgres:down"]
alias = 'd'
description = 'Tear down containers and destroy all data'
run = """
  mise run postgres:compose_down
  mise run postgres:destroy_data
"""

[tasks."postgres:compose_down"]
dir = "./tests"
description = "docker compose down"
run = 'docker compose down'

[tasks."postgres:destroy_data"]
alias = 'dd'
dir = "{{config_root}}"
description = "Removes the local data directories"
run = """
{% if os() == "linux" %}
{% set stat_cmd = "stat --format='%u'" %}
{% else %}
{% set stat_cmd = "stat -f '%Uu'" %}
{% endif %}
  set -e
  set -u
  if test -z "$(find tests/pg -maxdepth 1 -name 'data-*' -print -quit)"; then
    echo "no data directories to clean up - skipping"
    exit 0
  fi

  uid=$(id -u)
  for d in tests/pg/data-*; do
    sudo=""
    if [ "$({{stat_cmd}} ${d})" != "${uid}" ]; then
      sudo="sudo"
    fi
    echo "removing data directory ${d}"
    ${sudo} rm -rf ${d}
  done
"""

[tasks."postgres:install_eql"]
alias = 'e'
description = "Install EQL"
run = """
  #!/usr/bin/env bash
  cd tests
  curl -sLo sql/cipherstash-encrypt.sql https://github.com/cipherstash/encrypt-query-language/releases/latest/download/cipherstash-encrypt.sql
  cat sql/cipherstash-encrypt.sql | docker exec -i postgres${CONTAINER_SUFFIX} psql postgresql://${CS_DATABASE__USERNAME}:${CS_DATABASE__PASSWORD}@${CS_DATABASE__HOST}:${CS_DATABASE__PORT}/cipherstash -f-
"""

[tasks.build]
description = "Build releasable artifacts"
run = """
{% set default_platform = "linux/" ~ arch() | replace(from="x86_64", to="amd64") %}
mise run build:binary
mise run build:docker --platform {{option(name="platform",default=default_platform)}} \
"""

[tasks."build:binary"]
description = "Build a releasable binary for cipherstash-proxy"
run = """
cargo build --locked --release --package cipherstash-proxy
cp -v target/release/cipherstash-proxy .
"""

[tasks."build:docker"]
depends = ["build:docker:fetch_eql"]
description = "Build a Docker image for cipherstash-proxy"
run = """
{% set default_platform = "linux/" ~ arch() | replace(from="x86_64", to="amd64") %}
docker build . \
  --tag cipherstash/proxy:latest \
  --file proxy.Dockerfile \
  --platform {{option(name="platform",default=default_platform)}} \
"""

[tasks."build:docker:fetch_eql"]
description = "Fetch the EQL installation script"
run = """
if [ ! -e "cipherstash-eql.sql" ]; then
  echo "Fetching: cipherstash-eql.sql"
  curl -sLo cipherstash-eql.sql https://github.com/cipherstash/encrypt-query-language/releases/latest/download/cipherstash-encrypt.sql
else
  echo "Prefetched: cipherstash-eql.sql"
fi
"""

[tasks.release]
description = "Publish release artifacts"
depends = ["release:docker"]

[tasks."release:docker"]
description = "Release a Docker image for cipherstash-proxy"
run = """
if [ -z "$DOCKER_HUB_USERNAME" ] || [ -z "$DOCKER_HUB_PERSONAL_ACCESS_TOKEN" ]; then
  echo "error: no Docker Hub credentials provided"
  echo "error: please set DOCKER_HUB_USERNAME and DOCKER_HUB_PERSONAL_ACCESS_TOKEN"
  exit 2
fi
echo "Logging in to Docker Hub..."
echo $DOCKER_HUB_PERSONAL_ACCESS_TOKEN | docker login --username $DOCKER_HUB_USERNAME --password-stdin
docker tag cipherstash/proxy:latest cipherstash/proxy:latest
docker push cipherstash/proxy:latest
"""

# ====================================================================================================
