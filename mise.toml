[settings]
# Config for test environments
# Can be invoked with: mise --env tcp run <task>
trusted_config_paths = [
  "./tests/mise.toml",
  "./tests/mise.tcp.toml",
  "./tests/mise.tls.toml",
]

[task_config]
includes = ["tests/tasks"]

[vars]
database_port = "5532" # default postgres port using built in docker-compose setup

[env]
# Default configuration for running cipherstash-proxy out of the box
CS_DATABASE__NAME = "cipherstash"
CS_DATABASE__USERNAME = "cipherstash"
CS_DATABASE__PASSWORD = "password"
CS_DATABASE__HOST = "localhost"
CS_DATABASE__PORT = "5532"

[tools]
"cargo:cargo-binstall" = "latest"
"cargo:cargo-nextest" = "latest"
"cargo:cargo-sort" = "latest"

# ====================================================================================================
# Proxy Tasks
[tasks.proxy]
alias = 'p'
description = "Run the proxy (with `cargo run`)"
run = 'pwd && env | grep CS_ && cargo run'

[tasks."proxy:kill"]
alias = 'k'
description = "Kill running cipherstash-proxy processes"
run = """
  set +e
  killall cipherstash-proxy -s SIGINT
  exit 0
"""

[tasks."proxy:up"]
description = "Run Proxy instance with docker compose"
dir = "{{config_root}}/tests"
run = """
#!/bin/bash
{% set target = arch() ~ "-unknown-linux-gnu" | replace(from="arm64", to="aarch64") | replace(from="x64", to="x86_64") %}
{% set docker_platform = "linux/" ~ arch() | replace(from="x64", to="amd64") %}

{# If we are on macos, cross-compile for Linux, so we can run the binary in a Docker container. #}
{# Only supports Apple Silicon. #}
{% if os() == "macos" %}
if which aarch64-unknown-linux-gnu ; then
  brew install MaterializeInc/crosstools/aarch64-unknown-linux-gnu
fi
export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER={{ target }}-gcc
{% endif %}

# cross-compile
rustup target add --toolchain stable {{ target }}

cargo build --locked --target {{ target }} --release --package cipherstash-proxy

cp {{config_root}}/target/{{ target }}/release/cipherstash-proxy {{config_root}}/

# build a new container
mise run build:docker --platform {{docker_platform}}

if [[ "{{arg(name="service",default="proxy")}}" =~ "proxy-tls" ]]; then
  if [ -z "${CS_TLS__CERTIFICATE}" ]; then
    echo "error: CS_TLS__CERTIFICATE is not set, and you are trying to bring up the proxy-tls container"
  fi
  if [ -z "${CS_TLS__PRIVATE_KEY}" ]; then
    echo "error: CS_TLS__PRIVATE_KEY is not set, and you are trying to bring up the proxy-tls container"
  fi
  if [ -z "${CS_TLS__CERTIFICATE}" ] || [ -z "${CS_TLS__CERTIFICATE}" ]; then
    exit 67
  fi
fi

# Make the default invocation with `mise run proxy:up` work.
# The default mise environment configuration works for Proxy running as a process, connecting via a port forward.
# Try detecting a running postgres, and use it
if [ "${CS_DATABASE__HOST}" == "localhost" ]; then
  {% raw %}
  running_postgres="$(docker ps --filter "name=postgres" --filter "health=healthy" --format "{{.Names}};{{.Ports}}" | grep ${CS_DATABASE__PORT})"
  {% endraw %}
  if [ -z "${running_postgres}" ]; then
    echo "error: Could not detect a running, healthy postgres container with port ${CS_DATABASE__PORT}"
    echo "error: Try running 'mise run postgres:up' to start a container"
    exit 68
  fi
  echo $running_postgres
  export CS_DATABASE__HOST=$(echo $running_postgres | cut -d ';' -f 1)
  echo "Using postgres running in container: ${CS_DATABASE__HOST}"
fi

# run the container
echo docker compose up {{arg(name="service",default="proxy")}} {{option(name="extra-args",default="")}} | bash
"""

[tasks."proxy:down"]
dir = "{{config_root}}/tests"
description = "Tear down Proxy containers"
# `docker compose down` works differently on Linux and macOS.
# Depending on the operating system and version, services sometimes can't be named.
# Run `docker compose rm` directly, to emulate what `docker compose down` does.
run = "docker compose rm --stop --force proxy proxy-tls"

# ====================================================================================================
# Test Tasks

[tasks."test:unit"]
alias = ['t', 'test']
description = "Runs tests"
run = "mise run test:nextest {{arg(name='test',default='')}}"

[tasks."test:ci"]
alias = "ci"
description = "Runs test/s"
run = """
mise run test:integration
mise run test:check
mise run test:format
mise run test:clippy
mise run test:unit
"""

[tasks."test:wait_for_postgres_to_quack"]
dir = "{{config_root}}"
run = """
{% set default_host = get_env(name="CS_DATABASE__HOST",default="localhost") %}
{% set default_port = get_env(name="CS_DATABASE__PORT",default=5432) %}
host={{option(name="host",default=default_host)}}
port={{option(name="port",default=default_port)}}
tls={{flag(name="tls")}}
max_retries={{option(name="max-retries",default="4")}}
interval={{option(name="interval",default="0.5")}}
attempt=1
echo "Testing presence of Postgres at ${host}:${port} with a maximum of ${max_retries} retries"

postgres_ready () {
  # tls test
  if [ "$1" = "true" ]; then
    response="$(echo | openssl s_client -starttls postgres -connect $host:$port -state -no_ign_eof 2>&1)"
    success=$?
    if [ -n "${DEBUG}" ]; then
      echo "response: ${response}"
    fi
    return $success
  else
    # plaintext test
    response=$(cat tests/pg/startup_message.bin | nc -v -w 1 $host $port)
    if [ -n "${DEBUG}" ]; then
      echo "response: ${response}"
      echo "response: \\"${response}\\""
      echo -n ${response} | od -c
      echo -n ${response} | wc -c
      echo -n "\n" | od -c
    fi
    # FIXME(lindsay): also detect if we see TLS failures
    if [ -n "${response}" ]; then
      return 0
    fi
    return 1
  fi
}

until postgres_ready $tls
do
  if [ $attempt -lt $max_retries ]; then
    echo "Waiting for ${host}:${port}"
    sleep $interval
    attempt=$(expr $attempt + 1)
  else
    echo "Unable to connect to ${host}:${port} after ${max_retries} attempts"
    exit 64
  fi
done
echo "Connected to ${host}:${port} after ${attempt} attempts"
"""

[tasks."test:integration:preflight"]
description = "Ensure dependencies are ready for running the integration tests"
run = '''
set -u
set +e

# 5532: non-TLS, Postgres latest
# 5617: TLS, PostgreSQL version 17
ports="5532 5617"

for i in ${ports}; do
  mise run test:wait_for_postgres_to_quack --port ${i} --max-retries 20
  if [ $? -ne 0 ]; then
    echo "error: Postgres not running on port ${i}"
    echo "error: Try running 'mise run postgres:up' to start the containers"
    exit 66
  fi
done

# Ensure all Proxy services are stopped before we start the tests
mise --env tcp run proxy:down
'''

[tasks."test:integration"]
alias = "i"
dir = "./tests"
description = "Runs integration test/s"
run = """
set -e

###############################################
# Setup
###############################################

# Ensure Postgres instances are running
mise run test:integration:preflight

# Ensure EQL is set up before we try and start Proxy
mise --env tcp run postgres:setup
mise --env tls run postgres:setup

###############################################
# Test: non-TLS
###############################################

mise --env tcp run proxy:up proxy --extra-args "--detach --wait"
mise --env tcp run test:wait_for_postgres_to_quack --port 6432 --max-retries 20
mise --env tcp run test:psql-tcp
mise --env tcp run proxy:down

###############################################
# Test: TLS
###############################################

mise --env tls run proxy:up proxy-tls --extra-args "--detach --wait"
mise --env tls run test:wait_for_postgres_to_quack --port 6432 --max-retries 20 --tls
mise --env tls run test:psql-tls
mise --env tls run proxy:down

###############################################
# Test: integration
###############################################

mise --env tls run proxy:up proxy-tls --extra-args "--detach --wait"
mise --env tls run test:wait_for_postgres_to_quack --port 6432 --max-retries 20 --tls
cargo nextest run --no-fail-fast --nocapture -E 'test(~integration)'
mise --env tls run proxy:down
"""

[tasks."test:nextest"]
description = "Runs cargo nextest, skipping integration tests"
run = 'cargo nextest run --no-fail-fast --nocapture -E "not test(~integration)" {{arg(name="test",default="")}}'

[tasks."test:format"]
description = "Runs cargo fmt"
run = 'cargo fmt --all -- --check'

[tasks."test:check"]
description = "Runs cargo check"
run = 'cargo check'

[tasks."test:clippy"]
description = "Runs clippy"
run = 'cargo clippy --all --no-deps --all-targets --all-features'

[tasks."postgres:fail_if_not_running"]
description = "Check if postgres containers are running, and fail if not"
run = """
containers=$(docker ps --filter "name=postgres${CONTAINER_SUFFIX}" --quiet)
if [ -z "${containers}" ]; then
  echo "error: Docker containers for PostgreSQL are not running"
  echo "error: Try running 'mise run postgres:up' to start the containers"
  exit 65
fi
"""

[tasks."postgres:setup"]
alias = 's'
description = "Installs EQL and applies schema to database"
run = """
#!/bin/bash
cd tests
mise run postgres:fail_if_not_running
mise run postgres:eql:download
cat sql/cipherstash-encrypt.sql | docker exec -i postgres${CONTAINER_SUFFIX} psql postgresql://${CS_DATABASE__USERNAME}:${CS_DATABASE__PASSWORD}@${CS_DATABASE__HOST}:${CS_DATABASE__PORT}/cipherstash -f-
cat sql/schema.sql | docker exec -i postgres${CONTAINER_SUFFIX} psql postgresql://${CS_DATABASE__USERNAME}:${CS_DATABASE__PASSWORD}@${CS_DATABASE__HOST}:${CS_DATABASE__PORT}/cipherstash -f-
"""

[tasks."postgres:up"]
alias = 'u'
dir = "{{config_root}}/tests"
description = "Run Postgres instances with docker compose"
run = """
set -e
# Start the containers
echo docker compose up --build {{arg(name="service",default="postgres postgres-17-tls")}} {{option(name="extra-args",default="")}} | bash
"""

[tasks."postgres:down"]
alias = 'd'
description = 'Tear down containers and destroy all data'
run = """
  mise run postgres:compose_down
  mise run postgres:destroy_data
"""

[tasks."postgres:compose_down"]
dir = "./tests"
description = "docker compose down"
run = 'docker compose down'

[tasks."postgres:destroy_data"]
alias = 'dd'
dir = "{{config_root}}"
description = "Removes the local data directories"
run = """
{% if os() == "linux" %}
{% set stat_cmd = "stat --format='%u'" %}
{% else %}
{% set stat_cmd = "stat -f '%Uu'" %}
{% endif %}
set -e
set -u
if test -z "$(find tests/pg -maxdepth 1 -name 'data-*' -print -quit)"; then
  echo "no data directories to clean up - skipping"
  exit 0
fi

uid=$(id -u)
for d in tests/pg/data-*; do
  sudo=""
  if [ "$({{stat_cmd}} ${d})" != "${uid}" ]; then
    sudo="sudo"
  fi
  echo "removing data directory ${d}"
  ${sudo} rm -rf ${d}
done
"""

[tasks."postgres:eql:download"]
alias = 'e'
description = "Download latest EQL release"
dir = "{{config_root}}/tests"
outputs = ["{{config_root}}/tests/sql/cipherstash-encrypt.sql"]
run = "curl -sLo sql/cipherstash-encrypt.sql https://github.com/cipherstash/encrypt-query-language/releases/latest/download/cipherstash-encrypt.sql"

[tasks.build]
description = "Build releasable artifacts"
run = """
{% set default_platform = "linux/" ~ arch() | replace(from="x86_64", to="amd64") %}
mise run build:binary
mise run build:docker --platform {{option(name="platform",default=default_platform)}}
"""

[tasks."build:binary"]
description = "Build a releasable binary for cipherstash-proxy"
run = """
cargo build --locked --release --package cipherstash-proxy
cp -v target/release/cipherstash-proxy .
"""

[tasks."build:docker"]
depends = ["build:docker:fetch_eql"]
description = "Build a Docker image for cipherstash-proxy"
run = """
{% set default_platform = "linux/" ~ arch() | replace(from="x86_64", to="amd64") %}
docker build . \
  --tag cipherstash/proxy:latest \
  --file proxy.Dockerfile \
  --platform {{option(name="platform",default=default_platform)}} \
"""

[tasks."build:docker:fetch_eql"]
description = "Fetch the EQL installation script"
run = """
if [ ! -e "cipherstash-eql.sql" ]; then
  echo "Fetching: cipherstash-eql.sql"
  curl -sLo cipherstash-eql.sql https://github.com/cipherstash/encrypt-query-language/releases/latest/download/cipherstash-encrypt.sql
else
  echo "Prefetched: cipherstash-eql.sql"
fi
"""

[tasks.release]
description = "Publish release artifacts"
depends = ["release:docker"]

[tasks."release:docker"]
description = "Release a Docker image for cipherstash-proxy"
run = """
if [ -z "$DOCKER_HUB_USERNAME" ] || [ -z "$DOCKER_HUB_PERSONAL_ACCESS_TOKEN" ]; then
  echo "error: no Docker Hub credentials provided"
  echo "error: please set DOCKER_HUB_USERNAME and DOCKER_HUB_PERSONAL_ACCESS_TOKEN"
  exit 2
fi
echo "Logging in to Docker Hub..."
echo $DOCKER_HUB_PERSONAL_ACCESS_TOKEN | docker login --username $DOCKER_HUB_USERNAME --password-stdin
docker tag cipherstash/proxy:latest cipherstash/proxy:latest
docker push cipherstash/proxy:latest
"""

# ====================================================================================================
